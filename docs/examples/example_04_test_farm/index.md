# Create a test farm and distribute VM

## Intro

In this example we are going show a real use case scenario by using some hypervisor targets and deploy some VMs on these based on their libvirt virtualization capabilities.
Each VM will be assigned to each hypervisor target by using the `vm_dispatcher` role and will be provisioned with simple application build to test if at least compile successfully on different architectures.

Note: In this example hypervisors will be bare metal hosts only but the concept of hypervisor target can be applied on any inventory host that has at least a libvirt environment, so you can build first a test farm made up of VM hypervisors and distribute the (nested) VM over these ones like explained in the [nexted VM provisioning example](../example_03_nested_VM_provisioning_VDE/index.md). 

- [Full code](//github.com/jjak0b/test_farm/tree/master/docs/examples/example_04_test_farm/)

## Prerequisite

- [vm_dispatcher](../../roles/vm_dispatcher.md#Requirements ) role requirements
- [kvm_provision](../../roles/kvm_provision.md#Requirements ) role requirements
- [guest_provision](../../roles/guest_provision.md#Requirements ) role requirements

## Define the inventory

Let's define the inventory on different way:
- we have to specify the virtual machines configurations we want to generate on `localhost` (the ansible controller) but we won't it as hypervisor this time
- we have to specify some remote hypervisor hosts that will emulate the VMs, in this example will be the following ones assuming all requirements are already set up: 
  - `notebook_amd64`: is a notebook host with debian 11
  - `rpi_4_arm64`: is a Raspberry Pi 4 4GB with raspberry OS

```
all:
  hosts:
    localhost:
      ansible_connection: local
      config:
        permutations:
          targets:
            - 'amd64'
            - 'arm64'
            - 'ppc64'
          platforms:
            - 'debian_12'
        list:
          - platform: 'Arch-Linux'
            target: 'amd64'
  children:
    hypervisors:
      hosts:
        notebook_amd64:
          ansible_host: nb-jacopo.lan
          ansible_user: user
        rpi_4_arm64:
          ansible_host: 192.168.1.200
          ansible_user: pi
      vars:
        ansible_libvirt_uri: 'qemu:///session'
    Arch-Linux:
      vars:
        # arch image doesn't have python installed, so use ssh port-based waits instead
        wait_until_port_reachable: true
    arm64:
      vars:
        snapshot_type: external
    vms:
      vars:
        ansible_connection: ssh
        # ansible_host: localhost
        ansible_ssh_private_key_file: ~/.ssh/id_ssh_rsa_vm
        project_id: example_04
        project_revision: 0
        allowed_phases:
          - startup
          - restore init
          - create init
          - restore clean
          - create clean
          - dependencies
          - init
          - main
          - terminate
          - shutdown
```
Some notes are required:
- the `Arch-Linux` platform require `wait_until_port_reachable: true` since python is not installed but will be installed later, but until then we need to wait until SSH server is running.
- the `arm64` targets require to set a custom UEFI firmware but doing so [internal snapshots aren't supported by libvirt](https://unix.stackexchange.com/questions/663372/error-creating-snapshot-operation-not-supported-internal-snapshots-of-a-vm-wit), so we will use external snapshots instead by setting `snapshot_type: external`. 
- the `ansible_ssh_private_key_file: ~/.ssh/id_ssh_rsa_vm` wil be used as shared key eventually generated by the `setup_image.yaml` callback-task.
## Define platforms

The platforms are defined with the usual way, you may look the example source code to check them.

## Define targets

- **amd64**:
  ```
  - name: Define target definition
    set_fact:
      vm:
        metadata:
          target_name: amd64
        virt_domain: "{{ (ansible_architecture != 'x86_64') | ternary('qemu', 'kvm') }}"
        emulator: "/usr/bin/qemu-system-x86_64"
        arch: "x86_64"
        cpu: "{{ (ansible_architecture != 'x86_64') | ternary('qemu64', '') | default(omit, true) }}"
        machine: q35
  ```
- **arm64**
  ```
  - name: Define target definition
    set_fact:
      vm:
        metadata:
          target_name: arm64
        virt_domain: "{{ (ansible_architecture != 'aarch64') | ternary('qemu', 'kvm') }}"
        arch: "aarch64"
        emulator: "/usr/bin/qemu-system-aarch64"
        cpu: cortex-a53
        machine: virt
        vcpus: 1
        firmware: '/usr/share/AAVMF/AAVMF_CODE.fd'
  ```
- **ppc64**
  ```
  - name: Define target definition
    set_fact:
      vm:
        metadata:
          target_name: ppc64
        virt_domain: "{{ (ansible_architecture != 'ppc64le') | ternary('qemu', 'kvm') }}"
        arch: "ppc64le"
        emulator: "/usr/bin/qemu-system-ppc64le"
        cpu: POWER9
        machine: pseries
        vcpus: 1
        default_bus: pci.0
  ```

Note: **arm64** require to set the firmware as previously mentioned and **ppc64** require to change the default bus used by the user network device with the `pci.0` bus, since the architecure doesn't support PCIe controllers.

## Define the playbook

The `main.yaml` playbook is defined like the usual way but we add the `vm_dispatcher` role tha will dispatch the VM configurations over the running hypervisors by adding them as `config.list` items of a `VM configuration` such that it will be parsed by the `parse_vms_definitions` role as usual.

```
---
- hosts: localhost
  connection: local
  gather_facts: yes
  
- name: Init VM on Hypervisor
  hosts: hypervisors
  gather_facts: yes

  roles:
    - vm_dispatcher
    - parse_vms_definitions

  tasks:  

    - name: init VM connection
      loop: "{{ virtual_machines }}"

      include_role:
        name: init_vm_connection
      
      loop_control:
        loop_var: vm

- name: VM provisioning on Hypervisor host
  hosts: vms
  gather_facts: no
  tasks:

    - block:
      
        - name: gather min facts of hypervisor host since some definitions require to use them
          setup:
            gather_subset: 
            - '!all'
        
        - name: "start KVM Provision role for '{{ vm.metadata.name }}'"
          include_role: 
            name: kvm_provision

      delegate_to: "{{ kvm_host }}"
      tags:
        - kvm_provision
    - block:
        - name: "Start VM provisioning of '{{ vm.metadata.name }}' "
          include_role: 
            name: guest_provision

```

## Define the VM provisioning phases

## Run

```
ANSIBLE_CONFIG=ansible.cfg ansible-playbook main.yaml --extra-vars "@vars/vde.yaml"
```
