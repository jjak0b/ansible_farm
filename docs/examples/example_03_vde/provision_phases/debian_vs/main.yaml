# Simulate a playbook execution for this VM host
---

- name: "TODO: MOVE THIS TO DEPENDENCIES"
  package:
    name:
      - vde2
      - sshpass
      - bzip2
      - gzip
    state: present
  become: yes

- name: gather facts of hypervisor host since some definitions require to use them
  setup:
    gather_subset: 
    - 'all'

- import_role: 
    name: parse_vms_definitions

- name: init VM connection
  loop: "{{ virtual_machines }}"

  include_role:
    name: init_vm_connection
  vars:
    vm: "{{ L2vm }} "
  
  loop_control:
    loop_var: L2vm

- debug:
    var: inventory_hostname
- debug:
    var: myvar
  vars:
    myvar: "{{ hostvars[ 'VM debian_vs_vde_amd64' ] }}"

# Now VM are assigned to this L1 hypervisor
# We need to prevent this VM to terminate and cause L2 VMs to be unreachable
  

# - name: Wait until all VMs are processed
#   debug:
#     msg: "wait until {{ vm_inventory_names }} are processed"
#   until: vm_inventory_names is subset( query('inventory_hostnames', 'vms:&processed', wantlist=True) )
#   delay: 10
#   vars:
#     vm_inventory_names: "{{ virtual_machines | map( attribute='metadata') | map( attribute='name') }}"

